                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 4.0.0 #11528 (Linux)
                              4 ;--------------------------------------------------------
                              5 	.module driver
                              6 	.optsdcc -mz80
                              7 	
                              8 ;--------------------------------------------------------
                              9 ; Public variables in this module
                             10 ;--------------------------------------------------------
                             11 	.globl _read_or_write_sector
                             12 	.globl _caps_flash
                             13 	.globl _get_device_status
                             14 	.globl _get_device_info
                             15 	.globl _get_lun_info
                             16 	.globl _get_drive_config
                             17 	.globl _get_nr_drives_boottime
                             18 	.globl _onCallMOUNTDSK
                             19 	.globl _init_driver
                             20 	.globl _get_workarea_size
                             21 	.globl _interrupt
                             22 	.globl _get_workarea
                             23 	.globl _read_write_disk_sectors
                             24 	.globl _read_write_file_sectors
                             25 	.globl _usbdisk_select_dsk_file
                             26 	.globl _usbdisk_autoexec_dsk
                             27 	.globl _usbdisk_init
                             28 	.globl _hal_init
                             29 	.globl _puts
                             30 ;--------------------------------------------------------
                             31 ; special function registers
                             32 ;--------------------------------------------------------
                             33 ;--------------------------------------------------------
                             34 ; ram data
                             35 ;--------------------------------------------------------
                             36 	.area _DATA
                             37 ;--------------------------------------------------------
                             38 ; ram data
                             39 ;--------------------------------------------------------
                             40 	.area _INITIALIZED
                             41 ;--------------------------------------------------------
                             42 ; absolute external ram data
                             43 ;--------------------------------------------------------
                             44 	.area _DABS (ABS)
                             45 ;--------------------------------------------------------
                             46 ; global & static initialisations
                             47 ;--------------------------------------------------------
                             48 	.area _HOME
                             49 	.area _GSINIT
                             50 	.area _GSFINAL
                             51 	.area _GSINIT
                             52 ;--------------------------------------------------------
                             53 ; Home
                             54 ;--------------------------------------------------------
                             55 	.area _HOME
                             56 	.area _HOME
                             57 ;--------------------------------------------------------
                             58 ; code
                             59 ;--------------------------------------------------------
                             60 	.area _CODE
                             61 ;driver.c:12: workarea_t* get_workarea() __z88dk_fastcall __naked
                             62 ;	---------------------------------
                             63 ; Function get_workarea
                             64 ; ---------------------------------
   0000                      65 _get_workarea::
                             66 ;driver.c:27: __endasm;
                     4045    67 	GWORK	.equ 0x4045
                     4042    68 	CALBNK	.equ 0x4042
   0000 DD E5         [15]   69 	push	ix
   0002 AF            [ 4]   70 	xor	a
   0003 08            [ 4]   71 	ex	af,af' ;'
   0004 AF            [ 4]   72 	xor	a
   0005 DD 21 45 40   [14]   73 	LD	ix,#GWORK
   0009 CD 42 40      [17]   74 	call	CALBNK
   000C DD 6E 00      [19]   75 	ld	l,0(ix)
   000F DD 66 01      [19]   76 	ld	h,1(ix)
   0012 DD E1         [14]   77 	pop	ix
   0014 C9            [10]   78 	ret
                             79 ;driver.c:28: } 
                             80 ;driver.c:36: void interrupt ()
                             81 ;	---------------------------------
                             82 ; Function interrupt
                             83 ; ---------------------------------
   0015                      84 _interrupt::
                             85 ;driver.c:41: }
   0015 C9            [10]   86 	ret
                             87 ;driver.c:56: uint16_t get_workarea_size (uint8_t reduced_drive_count,uint8_t nr_available_drives)
                             88 ;	---------------------------------
                             89 ; Function get_workarea_size
                             90 ; ---------------------------------
   0016                      91 _get_workarea_size::
                             92 ;driver.c:62: return sizeof (workarea_t);
   0016 21 02 00      [10]   93 	ld	hl, #0x0002
                             94 ;driver.c:63: }
   0019 C9            [10]   95 	ret
                             96 ;driver.c:85: void init_driver (uint8_t reduced_drive_count,uint8_t nr_allocated_drives)
                             97 ;	---------------------------------
                             98 ; Function init_driver
                             99 ; ---------------------------------
   001A                     100 _init_driver::
   001A DD E5         [15]  101 	push	ix
                            102 ;driver.c:91: hal_init ();
   001C CDr00r00      [17]  103 	call	_hal_init
                            104 ;driver.c:92: workarea_t* workarea = get_workarea();
   001F CDr00r00      [17]  105 	call	_get_workarea
                            106 ;driver.c:93: usbdisk_init ();
   0022 E5            [11]  107 	push	hl
   0023 CDr00r00      [17]  108 	call	_usbdisk_init
   0026 CDr00r00      [17]  109 	call	_usbdisk_autoexec_dsk
   0029 7D            [ 4]  110 	ld	a, l
   002A E1            [10]  111 	pop	hl
   002B CB 47         [ 8]  112 	bit	0, a
   002D 28 04         [12]  113 	jr	Z,00102$
                            114 ;driver.c:95: workarea->mount_mode = 2;
   002F 36 02         [10]  115 	ld	(hl), #0x02
   0031 18 0C         [12]  116 	jr	00103$
   0033                     117 00102$:
                            118 ;driver.c:97: workarea->mount_mode = usbdisk_select_dsk_file ("/");
   0033 01r67r00      [10]  119 	ld	bc, #___str_0+0
   0036 E5            [11]  120 	push	hl
   0037 C5            [11]  121 	push	bc
   0038 CDr00r00      [17]  122 	call	_usbdisk_select_dsk_file
   003B F1            [10]  123 	pop	af
   003C 7D            [ 4]  124 	ld	a, l
   003D E1            [10]  125 	pop	hl
   003E 77            [ 7]  126 	ld	(hl), a
   003F                     127 00103$:
                            128 ;driver.c:98: switch (workarea->mount_mode)
   003F 7E            [ 7]  129 	ld	a, (hl)
   0040 FE 01         [ 7]  130 	cp	a, #0x01
   0042 28 0E         [12]  131 	jr	Z,00105$
   0044 D6 02         [ 7]  132 	sub	a, #0x02
   0046 20 14         [12]  133 	jr	NZ,00106$
                            134 ;driver.c:101: printf ("+Opened disk image\r\n");
   0048 21r69r00      [10]  135 	ld	hl, #___str_2
   004B E5            [11]  136 	push	hl
   004C CDr00r00      [17]  137 	call	_puts
   004F F1            [10]  138 	pop	af
                            139 ;driver.c:102: break;
   0050 18 12         [12]  140 	jr	00108$
                            141 ;driver.c:103: case 1:
   0052                     142 00105$:
                            143 ;driver.c:104: printf ("+Full disk mode\r\n");
   0052 21r7Dr00      [10]  144 	ld	hl, #___str_4
   0055 E5            [11]  145 	push	hl
   0056 CDr00r00      [17]  146 	call	_puts
   0059 F1            [10]  147 	pop	af
                            148 ;driver.c:105: break;
   005A 18 08         [12]  149 	jr	00108$
                            150 ;driver.c:106: default:
   005C                     151 00106$:
                            152 ;driver.c:107: printf ("+Using floppy disk\r\n");
   005C 21r8Er00      [10]  153 	ld	hl, #___str_6
   005F E5            [11]  154 	push	hl
   0060 CDr00r00      [17]  155 	call	_puts
   0063 F1            [10]  156 	pop	af
                            157 ;driver.c:109: }   
   0064                     158 00108$:
                            159 ;driver.c:110: }
   0064 DD E1         [14]  160 	pop	ix
   0066 C9            [10]  161 	ret
   0067                     162 ___str_0:
   0067 2F                  163 	.ascii "/"
   0068 00                  164 	.db 0x00
   0069                     165 ___str_2:
   0069 2B 4F 70 65 6E 65   166 	.ascii "+Opened disk image"
        64 20 64 69 73 6B
        20 69 6D 61 67 65
   007B 0D                  167 	.db 0x0d
   007C 00                  168 	.db 0x00
   007D                     169 ___str_4:
   007D 2B 46 75 6C 6C 20   170 	.ascii "+Full disk mode"
        64 69 73 6B 20 6D
        6F 64 65
   008C 0D                  171 	.db 0x0d
   008D 00                  172 	.db 0x00
   008E                     173 ___str_6:
   008E 2B 55 73 69 6E 67   174 	.ascii "+Using floppy disk"
        20 66 6C 6F 70 70
        79 20 64 69 73 6B
   00A0 0D                  175 	.db 0x0d
   00A1 00                  176 	.db 0x00
                            177 ;driver.c:112: void onCallMOUNTDSK ()
                            178 ;	---------------------------------
                            179 ; Function onCallMOUNTDSK
                            180 ; ---------------------------------
   00A2                     181 _onCallMOUNTDSK::
                            182 ;driver.c:114: hal_init ();
   00A2 CDr00r00      [17]  183 	call	_hal_init
                            184 ;driver.c:115: workarea_t* workarea = get_workarea();
   00A5 CDr00r00      [17]  185 	call	_get_workarea
                            186 ;driver.c:116: usbdisk_init ();
   00A8 E5            [11]  187 	push	hl
   00A9 CDr00r00      [17]  188 	call	_usbdisk_init
   00AC E1            [10]  189 	pop	hl
                            190 ;driver.c:117: workarea->mount_mode = usbdisk_select_dsk_file ("/");
   00AD 01rDDr00      [10]  191 	ld	bc, #___str_7+0
   00B0 E5            [11]  192 	push	hl
   00B1 C5            [11]  193 	push	bc
   00B2 CDr00r00      [17]  194 	call	_usbdisk_select_dsk_file
   00B5 F1            [10]  195 	pop	af
   00B6 7D            [ 4]  196 	ld	a, l
   00B7 E1            [10]  197 	pop	hl
   00B8 77            [ 7]  198 	ld	(hl), a
                            199 ;driver.c:118: switch (workarea->mount_mode)
   00B9 4E            [ 7]  200 	ld	c, (hl)
   00BA 3D            [ 4]  201 	dec	a
   00BB 28 0E         [12]  202 	jr	Z,00102$
   00BD 79            [ 4]  203 	ld	a, c
   00BE D6 02         [ 7]  204 	sub	a, #0x02
   00C0 20 12         [12]  205 	jr	NZ,00103$
                            206 ;driver.c:121: printf ("+Opened disk image\r\n");
   00C2 21rDFr00      [10]  207 	ld	hl, #___str_9
   00C5 E5            [11]  208 	push	hl
   00C6 CDr00r00      [17]  209 	call	_puts
   00C9 F1            [10]  210 	pop	af
                            211 ;driver.c:122: break;
   00CA C9            [10]  212 	ret
                            213 ;driver.c:123: case 1:
   00CB                     214 00102$:
                            215 ;driver.c:124: printf ("+Full disk mode\r\n");
   00CB 21rF3r00      [10]  216 	ld	hl, #___str_11
   00CE E5            [11]  217 	push	hl
   00CF CDr00r00      [17]  218 	call	_puts
   00D2 F1            [10]  219 	pop	af
                            220 ;driver.c:125: break;
   00D3 C9            [10]  221 	ret
                            222 ;driver.c:126: default:
   00D4                     223 00103$:
                            224 ;driver.c:127: printf ("+Using floppy disk\r\n");
   00D4 21r04r01      [10]  225 	ld	hl, #___str_13
   00D7 E5            [11]  226 	push	hl
   00D8 CDr00r00      [17]  227 	call	_puts
   00DB F1            [10]  228 	pop	af
                            229 ;driver.c:129: }   
                            230 ;driver.c:130: }
   00DC C9            [10]  231 	ret
   00DD                     232 ___str_7:
   00DD 2F                  233 	.ascii "/"
   00DE 00                  234 	.db 0x00
   00DF                     235 ___str_9:
   00DF 2B 4F 70 65 6E 65   236 	.ascii "+Opened disk image"
        64 20 64 69 73 6B
        20 69 6D 61 67 65
   00F1 0D                  237 	.db 0x0d
   00F2 00                  238 	.db 0x00
   00F3                     239 ___str_11:
   00F3 2B 46 75 6C 6C 20   240 	.ascii "+Full disk mode"
        64 69 73 6B 20 6D
        6F 64 65
   0102 0D                  241 	.db 0x0d
   0103 00                  242 	.db 0x00
   0104                     243 ___str_13:
   0104 2B 55 73 69 6E 67   244 	.ascii "+Using floppy disk"
        20 66 6C 6F 70 70
        79 20 64 69 73 6B
   0116 0D                  245 	.db 0x0d
   0117 00                  246 	.db 0x00
                            247 ;driver.c:142: uint8_t get_nr_drives_boottime (uint8_t reduced_drive_count,uint8_t dos_mode)
                            248 ;	---------------------------------
                            249 ; Function get_nr_drives_boottime
                            250 ; ---------------------------------
   0118                     251 _get_nr_drives_boottime::
                            252 ;driver.c:148: workarea_t* workarea = get_workarea();
   0118 CDr00r00      [17]  253 	call	_get_workarea
                            254 ;driver.c:149: if (workarea->mount_mode==0)
   011B 7E            [ 7]  255 	ld	a, (hl)
                            256 ;driver.c:150: return 0;
   011C B7            [ 4]  257 	or	a,a
   011D 20 02         [12]  258 	jr	NZ,00102$
   011F 6F            [ 4]  259 	ld	l,a
   0120 C9            [10]  260 	ret
   0121                     261 00102$:
                            262 ;driver.c:152: return 1; // 1 drive requested
   0121 2E 01         [ 7]  263 	ld	l, #0x01
                            264 ;driver.c:153: }
   0123 C9            [10]  265 	ret
                            266 ;driver.c:165: uint16_t get_drive_config (uint8_t relative_drive_number,uint8_t dos_mode)
                            267 ;	---------------------------------
                            268 ; Function get_drive_config
                            269 ; ---------------------------------
   0124                     270 _get_drive_config::
                            271 ;driver.c:171: return 0x0101; // device 1, lun 1
   0124 21 01 01      [10]  272 	ld	hl, #0x0101
                            273 ;driver.c:172: }
   0127 C9            [10]  274 	ret
                            275 ;driver.c:210: uint8_t get_lun_info (uint8_t nr_lun,uint8_t nr_device,luninfo_t* luninfo)
                            276 ;	---------------------------------
                            277 ; Function get_lun_info
                            278 ; ---------------------------------
   0128                     279 _get_lun_info::
                            280 ;driver.c:216: if (nr_lun==1 && nr_device==1)
   0128 FD 21 02 00   [14]  281 	ld	iy, #2
   012C FD 39         [15]  282 	add	iy, sp
   012E FD 7E 00      [19]  283 	ld	a, 0 (iy)
   0131 3D            [ 4]  284 	dec	a
   0132 20 2E         [12]  285 	jr	NZ,00102$
   0134 FD 23         [10]  286 	inc	iy
   0136 FD 7E 00      [19]  287 	ld	a, 0 (iy)
   0139 3D            [ 4]  288 	dec	a
   013A 20 26         [12]  289 	jr	NZ,00102$
                            290 ;driver.c:218: memset (luninfo,0,sizeof (luninfo_t));
   013C FD 23         [10]  291 	inc	iy
   013E FD 6E 00      [19]  292 	ld	l, 0 (iy)
   0141 FD 66 01      [19]  293 	ld	h, 1 (iy)
   0144 06 0C         [ 7]  294 	ld	b, #0x0c
   0146                     295 00120$:
   0146 36 00         [10]  296 	ld	(hl), #0x00
   0148 23            [ 6]  297 	inc	hl
   0149 10 FB         [13]  298 	djnz	00120$
                            299 ;driver.c:220: luninfo->sector_size = 512;
   014B FD 4E 00      [19]  300 	ld	c, 0 (iy)
   014E FD 46 01      [19]  301 	ld	b, 1 (iy)
   0151 69            [ 4]  302 	ld	l, c
   0152 60            [ 4]  303 	ld	h, b
   0153 23            [ 6]  304 	inc	hl
   0154 36 00         [10]  305 	ld	(hl), #0x00
   0156 23            [ 6]  306 	inc	hl
   0157 36 02         [10]  307 	ld	(hl), #0x02
                            308 ;driver.c:222: luninfo->flags = 0b00000001; // ; removable + non-read only + no floppy
   0159 21 07 00      [10]  309 	ld	hl, #0x0007
   015C 09            [11]  310 	add	hl, bc
   015D 36 01         [10]  311 	ld	(hl), #0x01
                            312 ;driver.c:226: return 0x00;
   015F 2E 00         [ 7]  313 	ld	l, #0x00
   0161 C9            [10]  314 	ret
   0162                     315 00102$:
                            316 ;driver.c:229: return 0x01;
   0162 2E 01         [ 7]  317 	ld	l, #0x01
                            318 ;driver.c:230: }
   0164 C9            [10]  319 	ret
                            320 ;driver.c:269: uint8_t get_device_info (uint8_t nr_info,uint8_t nr_device,uint8_t* info_buffer)
                            321 ;	---------------------------------
                            322 ; Function get_device_info
                            323 ; ---------------------------------
   0165                     324 _get_device_info::
   0165 DD E5         [15]  325 	push	ix
   0167 DD 21 00 00   [14]  326 	ld	ix,#0
   016B DD 39         [15]  327 	add	ix,sp
                            328 ;driver.c:275: if (nr_device!=1)
   016D DD 7E 05      [19]  329 	ld	a, 5 (ix)
   0170 3D            [ 4]  330 	dec	a
   0171 28 04         [12]  331 	jr	Z,00102$
                            332 ;driver.c:276: return 1;
   0173 2E 01         [ 7]  333 	ld	l, #0x01
   0175 18 68         [12]  334 	jr	00109$
   0177                     335 00102$:
                            336 ;driver.c:278: switch (nr_info)
   0177 DD 7E 04      [19]  337 	ld	a, 4 (ix)
   017A B7            [ 4]  338 	or	a, a
   017B 28 16         [12]  339 	jr	Z,00103$
   017D DD 7E 04      [19]  340 	ld	a, 4 (ix)
   0180 3D            [ 4]  341 	dec	a
   0181 28 23         [12]  342 	jr	Z,00104$
   0183 DD 7E 04      [19]  343 	ld	a, 4 (ix)
   0186 D6 02         [ 7]  344 	sub	a, #0x02
   0188 28 2D         [12]  345 	jr	Z,00105$
   018A DD 7E 04      [19]  346 	ld	a, 4 (ix)
   018D D6 03         [ 7]  347 	sub	a, #0x03
   018F 28 37         [12]  348 	jr	Z,00106$
   0191 18 46         [12]  349 	jr	00107$
                            350 ;driver.c:280: case 0: // basic information
   0193                     351 00103$:
                            352 ;driver.c:281: ((deviceinfo_t*)info_buffer)->nr_luns = 0x01;
   0193 DD 6E 06      [19]  353 	ld	l, 6 (ix)
   0196 DD 66 07      [19]  354 	ld	h, 7 (ix)
   0199 36 01         [10]  355 	ld	(hl), #0x01
                            356 ;driver.c:282: ((deviceinfo_t*)info_buffer)->flags = 0x00;
   019B DD 4E 06      [19]  357 	ld	c, 6 (ix)
   019E DD 46 07      [19]  358 	ld	b, 7 (ix)
   01A1 03            [ 6]  359 	inc	bc
   01A2 AF            [ 4]  360 	xor	a, a
   01A3 02            [ 7]  361 	ld	(bc), a
                            362 ;driver.c:283: break;
   01A4 18 37         [12]  363 	jr	00108$
                            364 ;driver.c:284: case 1: // Manufacturer name string
   01A6                     365 00104$:
                            366 ;driver.c:285: strcpy ((char*)info_buffer,"S0urceror");
   01A6 DD 5E 06      [19]  367 	ld	e, 6 (ix)
   01A9 DD 56 07      [19]  368 	ld	d, 7 (ix)
   01AC 21rE2r01      [10]  369 	ld	hl, #___str_14
   01AF AF            [ 4]  370 	xor	a, a
   01B0                     371 00141$:
   01B0 BE            [ 7]  372 	cp	a, (hl)
   01B1 ED A0         [16]  373 	ldi
   01B3 20 FB         [12]  374 	jr	NZ, 00141$
                            375 ;driver.c:286: break;
   01B5 18 26         [12]  376 	jr	00108$
                            377 ;driver.c:287: case 2: // Device name string
   01B7                     378 00105$:
                            379 ;driver.c:288: strcpy ((char*)info_buffer,"MSXUSBNext");
   01B7 DD 5E 06      [19]  380 	ld	e, 6 (ix)
   01BA DD 56 07      [19]  381 	ld	d, 7 (ix)
   01BD 21rECr01      [10]  382 	ld	hl, #___str_15
   01C0 AF            [ 4]  383 	xor	a, a
   01C1                     384 00142$:
   01C1 BE            [ 7]  385 	cp	a, (hl)
   01C2 ED A0         [16]  386 	ldi
   01C4 20 FB         [12]  387 	jr	NZ, 00142$
                            388 ;driver.c:289: break;
   01C6 18 15         [12]  389 	jr	00108$
                            390 ;driver.c:290: case 3: // Serial number string
   01C8                     391 00106$:
                            392 ;driver.c:291: strcpy ((char*)info_buffer,"0000");
   01C8 DD 5E 06      [19]  393 	ld	e, 6 (ix)
   01CB DD 56 07      [19]  394 	ld	d, 7 (ix)
   01CE 21rF7r01      [10]  395 	ld	hl, #___str_16
   01D1 AF            [ 4]  396 	xor	a, a
   01D2                     397 00143$:
   01D2 BE            [ 7]  398 	cp	a, (hl)
   01D3 ED A0         [16]  399 	ldi
   01D5 20 FB         [12]  400 	jr	NZ, 00143$
                            401 ;driver.c:292: break;
   01D7 18 04         [12]  402 	jr	00108$
                            403 ;driver.c:293: default:
   01D9                     404 00107$:
                            405 ;driver.c:294: return 2;
   01D9 2E 02         [ 7]  406 	ld	l, #0x02
   01DB 18 02         [12]  407 	jr	00109$
                            408 ;driver.c:296: }
   01DD                     409 00108$:
                            410 ;driver.c:297: return 0;
   01DD 2E 00         [ 7]  411 	ld	l, #0x00
   01DF                     412 00109$:
                            413 ;driver.c:298: }
   01DF DD E1         [14]  414 	pop	ix
   01E1 C9            [10]  415 	ret
   01E2                     416 ___str_14:
   01E2 53 30 75 72 63 65   417 	.ascii "S0urceror"
        72 6F 72
   01EB 00                  418 	.db 0x00
   01EC                     419 ___str_15:
   01EC 4D 53 58 55 53 42   420 	.ascii "MSXUSBNext"
        4E 65 78 74
   01F6 00                  421 	.db 0x00
   01F7                     422 ___str_16:
   01F7 30 30 30 30         423 	.ascii "0000"
   01FB 00                  424 	.db 0x00
                            425 ;driver.c:329: uint8_t get_device_status (uint8_t nr_lun,uint8_t nr_device)
                            426 ;	---------------------------------
                            427 ; Function get_device_status
                            428 ; ---------------------------------
   01FC                     429 _get_device_status::
                            430 ;driver.c:336: workarea_t* workarea = get_workarea();
   01FC CDr00r00      [17]  431 	call	_get_workarea
                            432 ;driver.c:346: return ret;
   01FF 2E 01         [ 7]  433 	ld	l, #0x01
                            434 ;driver.c:348: }
   0201 C9            [10]  435 	ret
                            436 ;driver.c:350: void caps_flash () __z88dk_fastcall __naked
                            437 ;	---------------------------------
                            438 ; Function caps_flash
                            439 ; ---------------------------------
   0202                     440 _caps_flash::
                            441 ;driver.c:365: __endasm;
                            442 ;	CAPS FLASH
   0202 DB AA         [11]  443 	in	a, (0xaa)
   0204 CB 77         [ 8]  444 	bit	6,a
   0206 28 04         [12]  445 	jr	z, _CAPS_FLASH_ON
   0208 CB B7         [ 8]  446 	res	6,a
   020A 18 02         [12]  447 	jr	_CAPS_FLASH
   020C                     448 	_CAPS_FLASH_ON:
   020C CB F7         [ 8]  449 	set	6,a
   020E                     450 	_CAPS_FLASH:
   020E D3 AA         [11]  451 	out	(0xaa),a
   0210 C9            [10]  452 	ret
                            453 ;
                            454 ;driver.c:366: }
                            455 ;driver.c:393: diskerror_t read_or_write_sector (uint8_t read_or_write_flag, uint8_t nr_device, uint8_t nr_lun, uint8_t nr_sectors, uint32_t* sector, uint8_t* sector_buffer)
                            456 ;	---------------------------------
                            457 ; Function read_or_write_sector
                            458 ; ---------------------------------
   0211                     459 _read_or_write_sector::
   0211 DD E5         [15]  460 	push	ix
   0213 DD 21 00 00   [14]  461 	ld	ix,#0
   0217 DD 39         [15]  462 	add	ix,sp
                            463 ;driver.c:402: workarea_t* workarea = get_workarea();
   0219 CDr00r00      [17]  464 	call	_get_workarea
                            465 ;driver.c:405: if (nr_device!=1 || nr_lun!=1)
   021C DD 7E 05      [19]  466 	ld	a, 5 (ix)
   021F 3D            [ 4]  467 	dec	a
   0220 20 06         [12]  468 	jr	NZ,00101$
   0222 DD 7E 06      [19]  469 	ld	a, 6 (ix)
   0225 3D            [ 4]  470 	dec	a
   0226 28 04         [12]  471 	jr	Z,00102$
   0228                     472 00101$:
                            473 ;driver.c:406: return IDEVL;
   0228 2E B5         [ 7]  474 	ld	l, #0xb5
   022A 18 56         [12]  475 	jr	00111$
   022C                     476 00102$:
                            477 ;driver.c:408: caps_flash ();
   022C E5            [11]  478 	push	hl
   022D CDr02r02      [17]  479 	call	_caps_flash
   0230 E1            [10]  480 	pop	hl
                            481 ;driver.c:410: if (workarea->mount_mode==2)
   0231 5E            [ 7]  482 	ld	e, (hl)
                            483 ;driver.c:414: if (!read_write_file_sectors (read_or_write_flag & Z80_CARRY_MASK,nr_sectors,sector,sector_buffer))
   0232 DD 7E 04      [19]  484 	ld	a, 4 (ix)
   0235 E6 01         [ 7]  485 	and	a, #0x01
   0237 4F            [ 4]  486 	ld	c, a
                            487 ;driver.c:410: if (workarea->mount_mode==2)
   0238 7B            [ 4]  488 	ld	a, e
   0239 D6 02         [ 7]  489 	sub	a, #0x02
   023B 20 20         [12]  490 	jr	NZ,00109$
                            491 ;driver.c:414: if (!read_write_file_sectors (read_or_write_flag & Z80_CARRY_MASK,nr_sectors,sector,sector_buffer))
   023D DD 6E 0A      [19]  492 	ld	l, 10 (ix)
   0240 DD 66 0B      [19]  493 	ld	h, 11 (ix)
   0243 E5            [11]  494 	push	hl
   0244 DD 6E 08      [19]  495 	ld	l, 8 (ix)
   0247 DD 66 09      [19]  496 	ld	h, 9 (ix)
   024A E5            [11]  497 	push	hl
   024B DD 46 07      [19]  498 	ld	b, 7 (ix)
   024E C5            [11]  499 	push	bc
   024F CDr00r00      [17]  500 	call	_read_write_file_sectors
   0252 F1            [10]  501 	pop	af
   0253 F1            [10]  502 	pop	af
   0254 F1            [10]  503 	pop	af
   0255 CB 45         [ 8]  504 	bit	0, l
   0257 20 24         [12]  505 	jr	NZ,00110$
                            506 ;driver.c:415: return RNF;
   0259 2E F9         [ 7]  507 	ld	l, #0xf9
   025B 18 25         [12]  508 	jr	00111$
   025D                     509 00109$:
                            510 ;driver.c:420: if (!read_write_disk_sectors (read_or_write_flag & Z80_CARRY_MASK,nr_sectors,sector,sector_buffer))
   025D DD 6E 0A      [19]  511 	ld	l, 10 (ix)
   0260 DD 66 0B      [19]  512 	ld	h, 11 (ix)
   0263 E5            [11]  513 	push	hl
   0264 DD 6E 08      [19]  514 	ld	l, 8 (ix)
   0267 DD 66 09      [19]  515 	ld	h, 9 (ix)
   026A E5            [11]  516 	push	hl
   026B DD 46 07      [19]  517 	ld	b, 7 (ix)
   026E C5            [11]  518 	push	bc
   026F CDr00r00      [17]  519 	call	_read_write_disk_sectors
   0272 F1            [10]  520 	pop	af
   0273 F1            [10]  521 	pop	af
   0274 F1            [10]  522 	pop	af
   0275 CB 45         [ 8]  523 	bit	0, l
   0277 20 04         [12]  524 	jr	NZ,00110$
                            525 ;driver.c:421: return RNF;
   0279 2E F9         [ 7]  526 	ld	l, #0xf9
   027B 18 05         [12]  527 	jr	00111$
   027D                     528 00110$:
                            529 ;driver.c:424: caps_flash ();
   027D CDr02r02      [17]  530 	call	_caps_flash
                            531 ;driver.c:426: return OK;
   0280 2E 00         [ 7]  532 	ld	l, #0x00
   0282                     533 00111$:
                            534 ;driver.c:427: }
   0282 DD E1         [14]  535 	pop	ix
   0284 C9            [10]  536 	ret
                            537 	.area _CODE
                            538 	.area _INITIALIZER
                            539 	.area _CABS (ABS)
